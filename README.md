# Контрольная работа № 3 Асинхронное межсервисное взаимодействие.

## Технологии
- Java 17
- Spring Boot 3.5.0
- Spring Data JPA
- PostgreSQL
- RabbitMQ

## Архитектура
Проект состоит из трех микросервисов:
1.  API Gateway – отвечает только за routing запросов;
2.  Order Service – отвечает за создание заказа, просмотра списка заказов и просмотра статуса заказа;
3.  Payments Service – отвечает за создание, пополнение и просмотра баланса счета. 

### 1. API Gateway
Все запросы проходят через этот микросервис, только он виден из контейнера на порту 8080.
Поддерживается 6 запросов, 3 из них перенаправляются к Order Service, и 3 - к Payments Service.
Запросы к Order Service:
- POST /orders - запрос на создание заказа. Параметры передаются в теле запроса (user_id, amount, description) как JSON.
- GET /orders?user={user_id} - запрос на получение списка заказов для заданного пользователя. Если опустить user_id, то будут возвращены заказы всех пользователей.
- GET /orders/{order_id} - запрос на просмотр статуса отдельного заказа.

Запросы к Payments Service:
- POST /payments - запрос на создание счета клиента. user_id клиента передается в теле запроса.
- PUT /payments/{user_id} - запрос на пополнение счета. Сумма передается в теле запроса.
- GET /payments/{user_id} - запрос на просмотр баланса счета.

Все запросы возвращают JSON, в котором есть два обязательных поля: status и message. status может быть "Success" или "Fail", в message может находится более подробное сообщение. Например, если API Gateway не может подключиться к какому либо сервису, он вернет следующее сообщение:
```JSON
{
    "status": "Fail",
    "message": "XXX Service temporarily unavailable."
}
```
В остальных случаях API Gateway просто пересылает ответ от другого сервиса.

### 2. Order Service
Этот сервис работает с таблицей `orders`, в которой сохряняются все заказы. Заказ это (`order_id`, `user_id`, `amount`, `description`, `status`). Статус это `NEW`, `FINISHED` или `CANCELLED`.
При получени запроса на создание заказа сервис создает новую запись в таблице со статусом `NEW`, отправляет клиенту ответ об успешном создании заказа, вместе с `order_id` созданного заказа.
Далее начинается асинхронный процесс оплаты заказа. Для этого сервис реализует паттерн `Transactional Outbox`. Имеется дополнительная таблица (`outbox_os`), в которую записываются данные заказа,
одновременно с записью в основную таблицу (в одной транзакции). Имеется фоновый процесс (`BgWorker`), который раз в секунду проверяет Outbox на наличие в нем записей. Все записи из этой таблицы
передаются этим процессом в очередь сообщений с таким же названием `outbox_os` (в качестве брокера сообщений используется RabbitMQ). На данном этапе записи из Outbox не удаляются.
В сервисе реализован приемник сообщений из другой очереди, `outbox_ps`, в которую Payments Service помещает сообщения о подверждении заказа (подверждение в данном случае означает не то, что заказ
оплачен, а то, что он прошел проверку Payments Service, и сменил статус на `FINISHED` или `CANCELLED`). После получения подтверждения заказ удаляется из Outbox. Таким образом, реализуется семанитика `at-least-once` для создания заказов - запрос на оплату обязательно попадет к Payments Service.

### 3. Payments Service
Этот сервис работает с таблицей `accounts`, в которой хранятся счета клиентов (тут всего два поля, `user_id` и `balance`). Помимо функциональности по созданию и пополнению счетов, сервис выполняет асинхронную
оплату заказов для клиентов. Для этого реализуются паттерны `Transactional Inbox` и `Transactional Outbox`. В сервисе реализован приемник сообщений из очереди `outbox_os` - сюда Order Service отправляет запросы на оплату. После получения запроса приемник сообщений помещает параметры заказа (`order_id`, `user_id`, `amount`, `status`) в таблицу `inbox` (поле `order_id` является уникальным здесь, также как и в таблице `orders`). Также в этой таблице имеется дополнительное поле `acked`, которое помогает достичь семантики `exactly-once`. Имеется фоновый процесс (`BgWorkerInbox`), который раз в секунду проверяет Inbox на наличие в нем записей. Когда слушатель сообщений из `outbox_os` получает запрос на оплату, он проверяет `inbox`. Если там нет записи с полученным `order_id`, то она создается. Но даже если и есть, поле `acked` устанавливается в false, то есть, Order Service требует подверждения запроса. Далее фоновый процесс `BgWorkerInbox` извлекает из `inbox` только не подтвержденные записи. Если запись имеет статус `NEW`, значит она еще не была обработана. В этом случае сервис начинает ее обработку - проверяет счет клиента, и если средств достаточно, то списывает сумму и помечает запись в `inbox` как `FINISHED`, в противном случае как `CANCELLED`, но в любом случае заказ теперь считается "обработанным", и сервис больше не будет обрабатывать его повторно, даже если Order Service снова пришлет запрос на подтверждение. В этом случае будет просто возвращен текущий статус заказа в `inbox` - `FINISHED` или `CANCELLED`. Таким образом обеспечивается семантика `exactly-once` при списании денег - деньги не смогут быть списаны повторно для одного и того же заказа. Далее фоновый процесс `BgWorkerInbox` помечает запись в `inbox` как `acked`, и записывает параметры заказа в другую таблицу - `outbox_ps`. Из этой таблицы другой фоновый процесс, `BgWorkerOutbox` извлекает все записи и отправляет их в одноименную очередь сообщений `outbox_ps`, которую слушает Order Service, который после получения соответствующего сообщения изменит статус заказа в своей таблице `orders`. Данный механизм обеспечивает надежную обработку заказов - при сбое в любом из компонентов системы (в любом из микросервисов, в броекре сообщений, в БД (конечно, за исключением катастрофического сбоя с потерей данных)) данные не будут потеряны, заказ пройдет обработку и Order Service получит подтверждение заказа (позитивное или негативное). Основным моментом, который нужно учитывать при реализации данных паттернов, является запись в основную и дополнительные таблицы в рамках одной транзакции - если этого не обеспечить, то механизм не будет работать. В разработанном проекте это достигалось с помощью использования аннотации `@Transactional`. Для избегания race condition при работе со счетами использовался pessimistic lock.

## Коллекция Postman
Была разработана коллекция Postman (файл `Shopping.postman_collection.json`), которая демонстририрует функциональность реализованных микросервисов, охватывая все API. Она содержит 7 запросов (они пронумерованы), лучше запускать их последовательно с чистой БД. Первый запрос создает счет для клиента с `user_id`=1 (можно запустить два раза, чтобы убедится, что сервис не создат счет повторно), второй пополняет ему счет на 1000, третий проверяет баланс, четвертый создает заказ со стоимостью 1000 (это нужно выполнить два раза, так как второй заказ на ту же сумму не сможет быть оплачен и его статус в итоге будут `CANCELLED`), пятый получает список заказов для одного клиента, а шестой - для всех. Седьмой запрос проверяет статус конкретного заказа.

## Docker
Все микросервисы упакованы в Docker-контейнеры. Вся система разворачиваться с помощью docker-compose.yml (запускается командой docker compose up ). Всего в файле пять контейнеров - PostgreSQL, 
RabbitMQ и три разработанных микросервиса. Снаружи виден только API Gateway на порту 8080. Параметры для контейнеров находятся в файле .env.